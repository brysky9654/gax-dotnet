// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/usage.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Api {

  /// <summary>Holder for reflection information generated from google/api/usage.proto</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class UsageReflection {

    #region Descriptor
    /// <summary>File descriptor for google/api/usage.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static UsageReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZnb29nbGUvYXBpL3VzYWdlLnByb3RvEgpnb29nbGUuYXBpIqACCgVVc2Fn",
            "ZRI3Cg5zZXJ2aWNlX2FjY2VzcxgEIAEoDjIfLmdvb2dsZS5hcGkuVXNhZ2Uu",
            "U2VydmljZUFjY2VzcxIUCgxyZXF1aXJlbWVudHMYASADKAkSGwoTZGVwZW5k",
            "c19vbl9zZXJ2aWNlcxgCIAMoCRIYChBhY3RpdmF0aW9uX2hvb2tzGAMgAygJ",
            "EhoKEmRlYWN0aXZhdGlvbl9ob29rcxgFIAMoCRIkCgVydWxlcxgGIAMoCzIV",
            "Lmdvb2dsZS5hcGkuVXNhZ2VSdWxlIk8KDVNlcnZpY2VBY2Nlc3MSDgoKUkVT",
            "VFJJQ1RFRBAAEgoKBlBVQkxJQxABEhIKDk9SR19SRVNUUklDVEVEEAISDgoK",
            "T1JHX1BVQkxJQxADIj8KCVVzYWdlUnVsZRIQCghzZWxlY3RvchgBIAEoCRIg",
            "ChhhbGxvd191bnJlZ2lzdGVyZWRfY2FsbHMYAiABKAhCHgoOY29tLmdvb2ds",
            "ZS5hcGlCClVzYWdlUHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.Usage), global::Google.Api.Usage.Parser, new[]{ "ServiceAccess", "Requirements", "DependsOnServices", "ActivationHooks", "DeactivationHooks", "Rules" }, null, new[]{ typeof(global::Google.Api.Usage.Types.ServiceAccess) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Api.UsageRule), global::Google.Api.UsageRule.Parser, new[]{ "Selector", "AllowUnregisteredCalls" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///  Configuration controlling usage of a service.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Usage : pb::IMessage<Usage> {
    private static readonly pb::MessageParser<Usage> _parser = new pb::MessageParser<Usage>(() => new Usage());
    public static pb::MessageParser<Usage> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Api.UsageReflection.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public Usage() {
      OnConstruction();
    }

    partial void OnConstruction();

    public Usage(Usage other) : this() {
      serviceAccess_ = other.serviceAccess_;
      requirements_ = other.requirements_.Clone();
      dependsOnServices_ = other.dependsOnServices_.Clone();
      activationHooks_ = other.activationHooks_.Clone();
      deactivationHooks_ = other.deactivationHooks_.Clone();
      rules_ = other.rules_.Clone();
    }

    public Usage Clone() {
      return new Usage(this);
    }

    /// <summary>Field number for the "service_access" field.</summary>
    public const int ServiceAccessFieldNumber = 4;
    private global::Google.Api.Usage.Types.ServiceAccess serviceAccess_ = 0;
    /// <summary>
    ///  Controls which users can see or activate the service.
    /// </summary>
    public global::Google.Api.Usage.Types.ServiceAccess ServiceAccess {
      get { return serviceAccess_; }
      set {
        serviceAccess_ = value;
      }
    }

    /// <summary>Field number for the "requirements" field.</summary>
    public const int RequirementsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_requirements_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> requirements_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  Requirements that must be satisfied before a consumer project can use the
    ///  service. Each requirement is of the form &lt;service.name>/&lt;requirement-id>;
    ///  for example 'serviceusage.googleapis.com/billing-enabled'.
    /// </summary>
    public pbc::RepeatedField<string> Requirements {
      get { return requirements_; }
    }

    /// <summary>Field number for the "depends_on_services" field.</summary>
    public const int DependsOnServicesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_dependsOnServices_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> dependsOnServices_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  Services that must be activated in order for this service to be used.
    ///  The set of services activated as a result of these relations are all
    ///  activated in parallel with no guaranteed order of activation.
    ///  Each string is a service name, e.g. `calendar.googleapis.com`.
    /// </summary>
    public pbc::RepeatedField<string> DependsOnServices {
      get { return dependsOnServices_; }
    }

    /// <summary>Field number for the "activation_hooks" field.</summary>
    public const int ActivationHooksFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_activationHooks_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> activationHooks_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  Services that must be contacted before a consumer can begin using the
    ///  service. Each service will be contacted in sequence, and, if any activation
    ///  call fails, the entire activation will fail. Each hook is of the form
    ///  &lt;service.name>/&lt;hook-id>, where &lt;hook-id> is optional; for example:
    ///  'robotservice.googleapis.com/default'.
    /// </summary>
    public pbc::RepeatedField<string> ActivationHooks {
      get { return activationHooks_; }
    }

    /// <summary>Field number for the "deactivation_hooks" field.</summary>
    public const int DeactivationHooksFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_deactivationHooks_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> deactivationHooks_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///  Services that must be contacted before a consumer can deactivate a
    ///  service. Each service will be contacted in sequence, and, if any
    ///  deactivation call fails, the entire deactivation will fail. Each hook is
    ///  of the form &lt;service.name>/&lt;hook-id>, where &lt;hook-id> is optional; for
    ///  example:
    ///  'compute.googleapis.com/'.
    /// </summary>
    public pbc::RepeatedField<string> DeactivationHooks {
      get { return deactivationHooks_; }
    }

    /// <summary>Field number for the "rules" field.</summary>
    public const int RulesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Google.Api.UsageRule> _repeated_rules_codec
        = pb::FieldCodec.ForMessage(50, global::Google.Api.UsageRule.Parser);
    private readonly pbc::RepeatedField<global::Google.Api.UsageRule> rules_ = new pbc::RepeatedField<global::Google.Api.UsageRule>();
    /// <summary>
    ///  Individual rules for configuring usage on selected methods.
    /// </summary>
    public pbc::RepeatedField<global::Google.Api.UsageRule> Rules {
      get { return rules_; }
    }

    public override bool Equals(object other) {
      return Equals(other as Usage);
    }

    public bool Equals(Usage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServiceAccess != other.ServiceAccess) return false;
      if(!requirements_.Equals(other.requirements_)) return false;
      if(!dependsOnServices_.Equals(other.dependsOnServices_)) return false;
      if(!activationHooks_.Equals(other.activationHooks_)) return false;
      if(!deactivationHooks_.Equals(other.deactivationHooks_)) return false;
      if(!rules_.Equals(other.rules_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (ServiceAccess != 0) hash ^= ServiceAccess.GetHashCode();
      hash ^= requirements_.GetHashCode();
      hash ^= dependsOnServices_.GetHashCode();
      hash ^= activationHooks_.GetHashCode();
      hash ^= deactivationHooks_.GetHashCode();
      hash ^= rules_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      requirements_.WriteTo(output, _repeated_requirements_codec);
      dependsOnServices_.WriteTo(output, _repeated_dependsOnServices_codec);
      activationHooks_.WriteTo(output, _repeated_activationHooks_codec);
      if (ServiceAccess != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) ServiceAccess);
      }
      deactivationHooks_.WriteTo(output, _repeated_deactivationHooks_codec);
      rules_.WriteTo(output, _repeated_rules_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (ServiceAccess != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ServiceAccess);
      }
      size += requirements_.CalculateSize(_repeated_requirements_codec);
      size += dependsOnServices_.CalculateSize(_repeated_dependsOnServices_codec);
      size += activationHooks_.CalculateSize(_repeated_activationHooks_codec);
      size += deactivationHooks_.CalculateSize(_repeated_deactivationHooks_codec);
      size += rules_.CalculateSize(_repeated_rules_codec);
      return size;
    }

    public void MergeFrom(Usage other) {
      if (other == null) {
        return;
      }
      if (other.ServiceAccess != 0) {
        ServiceAccess = other.ServiceAccess;
      }
      requirements_.Add(other.requirements_);
      dependsOnServices_.Add(other.dependsOnServices_);
      activationHooks_.Add(other.activationHooks_);
      deactivationHooks_.Add(other.deactivationHooks_);
      rules_.Add(other.rules_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            requirements_.AddEntriesFrom(input, _repeated_requirements_codec);
            break;
          }
          case 18: {
            dependsOnServices_.AddEntriesFrom(input, _repeated_dependsOnServices_codec);
            break;
          }
          case 26: {
            activationHooks_.AddEntriesFrom(input, _repeated_activationHooks_codec);
            break;
          }
          case 32: {
            serviceAccess_ = (global::Google.Api.Usage.Types.ServiceAccess) input.ReadEnum();
            break;
          }
          case 42: {
            deactivationHooks_.AddEntriesFrom(input, _repeated_deactivationHooks_codec);
            break;
          }
          case 50: {
            rules_.AddEntriesFrom(input, _repeated_rules_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Usage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      /// <summary>
      ///  Service access types.
      ///
      ///  Access to restricted API features is always controlled by
      ///  [visibility][google.api.Visibility], independent of the ServiceAccess type.
      /// </summary>
      public enum ServiceAccess {
        /// <summary>
        ///  The service can only be seen/used by users identified in the service's
        ///  access control policy.
        ///
        ///  If the service has not been whitelisted by your domain administrator
        ///  for out-of-org publishing, then this mode will be treated like
        ///  ORG_RESTRICTED.
        /// </summary>
        [pbr::OriginalName("RESTRICTED")] Restricted = 0,
        /// <summary>
        ///  The service can be seen/used by anyone.
        ///
        ///  If the service has not been whitelisted by your domain administrator
        ///  for out-of-org publishing, then this mode will be treated like
        ///  ORG_PUBLIC.
        ///
        ///  The discovery document for the service will also be public and allow
        ///  unregistered access.
        /// </summary>
        [pbr::OriginalName("PUBLIC")] Public = 1,
        /// <summary>
        ///  The service can be seen/used by users identified in the service's
        ///  access control policy and they are within the organization that owns the
        ///  service.
        ///
        ///  Access is further constrained to the group
        ///  controlled by the administrator of the project/org that owns the
        ///  service.
        /// </summary>
        [pbr::OriginalName("ORG_RESTRICTED")] OrgRestricted = 2,
        /// <summary>
        ///  The service can be seen/used by the group of users controlled by the
        ///  administrator of the project/org that owns the service.
        /// </summary>
        [pbr::OriginalName("ORG_PUBLIC")] OrgPublic = 3,
      }

    }
    #endregion

  }

  /// <summary>
  ///  Usage configuration rules for the service.
  ///
  ///  NOTE: Under development.
  ///
  ///  Use this rule to configure unregistered calls for the service. Unregistered
  ///  calls are calls that do not contain consumer project identity.
  ///  (Example: calls that do not contain an API key).
  ///  By default, API methods do not allow unregistered calls, and each method call
  ///  must be identified by a consumer project identity. Use this rule to
  ///  allow/disallow unregistered calls.
  ///
  ///  Example of an API that wants to allow unregistered calls for entire service.
  ///
  ///      usage:
  ///        rules:
  ///        - selector: "*"
  ///          allow_unregistered_calls: true
  ///
  ///  Example of a method that wants to allow unregistered calls.
  ///
  ///      usage:
  ///        rules:
  ///        - selector: "google.example.library.v1.LibraryService.CreateBook"
  ///          allow_unregistered_calls: true
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class UsageRule : pb::IMessage<UsageRule> {
    private static readonly pb::MessageParser<UsageRule> _parser = new pb::MessageParser<UsageRule>(() => new UsageRule());
    public static pb::MessageParser<UsageRule> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Api.UsageReflection.Descriptor.MessageTypes[1]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public UsageRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    public UsageRule(UsageRule other) : this() {
      selector_ = other.selector_;
      allowUnregisteredCalls_ = other.allowUnregisteredCalls_;
    }

    public UsageRule Clone() {
      return new UsageRule(this);
    }

    /// <summary>Field number for the "selector" field.</summary>
    public const int SelectorFieldNumber = 1;
    private string selector_ = "";
    /// <summary>
    ///  Selects the methods to which this rule applies. Use '*' to indicate all
    ///  methods in all APIs.
    ///
    ///  Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
    /// </summary>
    public string Selector {
      get { return selector_; }
      set {
        selector_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_unregistered_calls" field.</summary>
    public const int AllowUnregisteredCallsFieldNumber = 2;
    private bool allowUnregisteredCalls_;
    /// <summary>
    ///  True, if the method allows unregistered calls; false otherwise.
    /// </summary>
    public bool AllowUnregisteredCalls {
      get { return allowUnregisteredCalls_; }
      set {
        allowUnregisteredCalls_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as UsageRule);
    }

    public bool Equals(UsageRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Selector != other.Selector) return false;
      if (AllowUnregisteredCalls != other.AllowUnregisteredCalls) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (Selector.Length != 0) hash ^= Selector.GetHashCode();
      if (AllowUnregisteredCalls != false) hash ^= AllowUnregisteredCalls.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (Selector.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Selector);
      }
      if (AllowUnregisteredCalls != false) {
        output.WriteRawTag(16);
        output.WriteBool(AllowUnregisteredCalls);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (Selector.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Selector);
      }
      if (AllowUnregisteredCalls != false) {
        size += 1 + 1;
      }
      return size;
    }

    public void MergeFrom(UsageRule other) {
      if (other == null) {
        return;
      }
      if (other.Selector.Length != 0) {
        Selector = other.Selector;
      }
      if (other.AllowUnregisteredCalls != false) {
        AllowUnregisteredCalls = other.AllowUnregisteredCalls;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Selector = input.ReadString();
            break;
          }
          case 16: {
            AllowUnregisteredCalls = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
